{"version":3,"sources":["webpack:///./customHooks/usePrevious.js","webpack:///./googleCloud/api/GoogleCloudApi.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///./customHooks/useServer.js","webpack:///./googleCloud/utils/getServers.js","webpack:///./customHooks/useQuery.js"],"names":["usePrevious","value","ref","useRef","useEffect","current","GoogleCloudApi","accessToken","console","error","this","project","location","dataset","dicomStore","urlBase","urlStr","config","params","url","URL","data","search","URLSearchParams","fetch","fetchConfig","response","json","status","nextPageToken","pageToken","doRequest","key","subPage","hasOwnProperty","concat","isError","message","projectId","urlBaseProject","locationId","access_token","window","Error","method","headers","Authorization","healthcareApiEndpoint","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","utils","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_promoteStudyDisplaySet","list","values","searchMethod","listCopy","promotedCount","arrayValues","Object","keys","length","seriesInstanceUID","promotedResponse","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","split","forEach","index","findIndex","bind","undefined","itemToPromote","splice","displaySets","_isQueryParamApplied","applied","seriesInstanceUIDs","validateFilterApplied","arrayToInspect","every","item","some","seriesInstanceUIDStr","validatePromoteApplied","isValid","resultSeries","series","validateMethod","_showUserMessage","queryParamApplied","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","get","add","_updateStudyDisplaySets","createDisplaySets","_addDerivedDisplaySets","_thinStudyData","map","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","studyInstanceUIDs","clearViewportSpecificData","setStudyData","useState","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","Array","isArray","filter","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","log","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","loadStudies","retrieveParams","push","splitQueryParameterCalls","enableGoogleCloudAdapter","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","e","includes","purge","content","JSON","stringify","NotFound","ConnectedViewer","propTypes","PropTypes","array","isRequired","object","func","OHIF","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","dispatch","getActiveServer","getServers","pathUrl","getUrlBaseDicomWeb","wadoUriRoot","qidoRoot","wadoRoot","GoogleCloudUtilServers","isValidServer","setServers","type","useServerFromUrl","previousServers","urlBasedServers","serverHasChanged","newServer","exists","useServer","useSelector","useDispatch","name","imageRendering","thumbnailRendering","supportsFuzzyMatching","qidoSupportsIncludeField","isEqualServer","toCompare","serverLength","toCompareLength","useLocation"],"mappings":"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","file":"DentalViewerRouting~ViewerRouting.bundle.0d04cbb4f95c57ba65de.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","class GoogleCloudApi {\n  setAccessToken(accessToken) {\n    if (!accessToken) console.error('Access token is empty');\n    this.accessToken = accessToken;\n  }\n\n  get fetchConfig() {\n    const access_token = this.accessToken || window.access_token;\n    if (!access_token) throw new Error('OIDC access_token is not set');\n    return {\n      method: 'GET',\n      headers: {\n        Authorization: 'Bearer ' + access_token,\n      },\n    };\n  }\n\n  get urlBase() {\n    return this.healthcareApiEndpoint || 'https://healthcare.googleapis.com/v1beta1';\n  }\n\n  set urlBase(url) {\n    this.healthcareApiEndpoint = url;\n  }\n\n  get urlBaseProject() {\n    return this.urlBase + `/projects`;\n  }\n\n  getUrlBaseDicomWeb(project, location, dataset, dicomStore) {\n    return (\n      this.urlBase +\n      `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}/dicomWeb`\n    );\n  }\n\n  getUrlPath(project, location, dataset, dicomStore) {\n    `/projects/${project}/locations/${location}/datasets/${dataset}/dicomStores/${dicomStore}`;\n  }\n\n  async doRequest(urlStr, config = {}, params = {}) {\n    const url = new URL(urlStr);\n    let data = null;\n    url.search = new URLSearchParams(params);\n\n    try {\n      const response = await fetch(url, { ...this.fetchConfig, config });\n      try {\n        data = await response.json();\n      } catch (err) {}\n      if (response.status >= 200 && response.status < 300 && data != null) {\n        if (data.nextPageToken != null) {\n          params.pageToken = data.nextPageToken;\n          let subPage = await this.doRequest(urlStr, config, params);\n          for (let key in data) {\n            if (data.hasOwnProperty(key)) {\n              data[key] = data[key].concat(subPage.data[key]);\n            }\n          }\n        }\n        return {\n          isError: false,\n          status: response.status,\n          data,\n        };\n      } else {\n        return {\n          isError: true,\n          status: response.status,\n          message:\n            (data && data.error && data.error.message) || 'Unknown error',\n        };\n      }\n    } catch (err) {\n      if (data && data.error) {\n        return {\n          isError: true,\n          status: err.status,\n          message: err.response.data.error.message || 'Unspecified error',\n        };\n      }\n      return {\n        isError: true,\n        message: (err && err.message) || 'Oops! Something went wrong',\n      };\n    }\n  }\n\n  async loadProjects() {\n    return this.doRequest(\n      'https://cloudresourcemanager.googleapis.com/v1/projects'\n    );\n  }\n\n  async loadLocations(projectId) {\n    return this.doRequest(`${this.urlBaseProject}/${projectId}/locations`);\n  }\n\n  async loadDatasets(projectId, locationId) {\n    return this.doRequest(\n      `${this.urlBaseProject}/${projectId}/locations/${locationId}/datasets`\n    );\n  }\n\n  async loadDicomStores(dataset) {\n    return this.doRequest(`${this.urlBase}/${dataset}/dicomStores`);\n  }\n}\n\nexport default new GoogleCloudApi();\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\n\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from './../App.js';\nimport { useSnackbarContext, ErrorPage } from '@ohif/ui';\n\n// Contexts\nimport AppContext from '../context/AppContext';\nimport NotFound from '../routes/NotFound';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, makeCancelable } = utils;\n\nconst _promoteToFront = (list, values, searchMethod) => {\n  let listCopy = [...list];\n  let response = [];\n  let promotedCount = 0;\n\n  const arrayValues = values.split(',');\n  arrayValues.forEach(value => {\n    const index = listCopy.findIndex(searchMethod.bind(undefined, value));\n\n    if (index >= 0) {\n      const [itemToPromote] = listCopy.splice(index, 1);\n      response[promotedCount] = itemToPromote;\n      promotedCount++;\n    }\n  });\n\n  return {\n    promoted: promotedCount === arrayValues.length,\n    data: [...response, ...listCopy],\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.SeriesInstanceUID === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n  let applied = true;\n  // skip in case no filter or no toast manager\n\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n  const seriesInstanceUIDs = seriesInstanceUID.split(',');\n\n  let validateFilterApplied = () => {\n    const sameSize = arrayToInspect.length === seriesInstanceUIDs.length;\n    if (!sameSize) {\n      return;\n    }\n\n    return arrayToInspect.every(item =>\n      seriesInstanceUIDs.some(\n        seriesInstanceUIDStr => seriesInstanceUIDStr === item.SeriesInstanceUID\n      )\n    );\n  };\n\n  let validatePromoteApplied = () => {\n    let isValid = true;\n    for (let index = 0; index < seriesInstanceUIDs.length; index++) {\n      const seriesInstanceUIDStr = seriesInstanceUIDs[index];\n      const resultSeries = arrayToInspect[index];\n\n      if (\n        !resultSeries ||\n        resultSeries.SeriesInstanceUID !== seriesInstanceUIDStr\n      ) {\n        isValid = false;\n        break;\n      }\n    }\n    return isValid;\n  };\n\n  const { series = [], displaySets = [] } = study;\n  const arrayToInspect = isFilterStrategy ? series : displaySets;\n  const validateMethod = isFilterStrategy\n    ? validateFilterApplied\n    : validatePromoteApplied;\n\n  if (!arrayToInspect) {\n    applied = false;\n  } else {\n    applied = validateMethod();\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => {} } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\n  if (existingSeries) {\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\n  } else {\n    studyMetadata.addSeries(seriesMetadata);\n  }\n\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata\n  );\n\n  study.displaySets = studyMetadata.getDisplaySets();\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\n    Modality: series.Modality,\n  });\n\n  _updateStudyMetadataManager(study, studyMetadata);\n};\n\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\n  const { StudyInstanceUID } = study;\n\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n  }\n\n  if (study.derivedDisplaySets) {\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\n  }\n};\n\nconst _thinStudyData = study => {\n  return {\n    StudyInstanceUID: study.StudyInstanceUID,\n    series: study.series.map(item => ({\n      SeriesInstanceUID: item.SeriesInstanceUID,\n    })),\n  };\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUIDs,\n  seriesInstanceUIDs,\n  clearViewportSpecificData,\n  setStudyData,\n}) {\n  // hooks\n  const [error, setError] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const {\n    filterQueryParam: isFilterStrategy = false,\n    maxConcurrentMetadataRequests,\n  } = appConfig;\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not totally applied. It might be using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n    setIsStudyLoaded(true);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filters.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters) => {\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studiesData_ = studiesData.filter(study => study !== null);\n      const studies = studiesData_.map(study => {\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.StudyInstanceUID\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateStudyMetadataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\n          loadRemainingSeries(studyMetadata)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(error);\n              log.error(error);\n            }\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const forceRerender = () => setStudies(studies => [...studies]);\n\n  const loadRemainingSeries = async studyMetadata => {\n    const { seriesLoader } = studyMetadata.getData();\n    if (!seriesLoader) return;\n\n    const loadNextSeries = async () => {\n      if (!seriesLoader.hasNext()) return;\n      const series = await seriesLoader.next();\n      _addSeriesToStudy(studyMetadata, series);\n      forceRerender();\n      return loadNextSeries();\n    };\n\n    const concurrentRequestsAllowed =\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\n    const promises = Array(concurrentRequestsAllowed)\n      .fill(null)\n      .map(loadNextSeries);\n\n    return await Promise.all(promises);\n  };\n\n  const loadStudies = async () => {\n    try {\n      const filters = {};\n      // Use the first, discard others\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\n      const retrieveParams = [server, studyInstanceUIDs];\n\n      if (seriesInstanceUID) {\n        filters.seriesInstanceUID = seriesInstanceUID;\n        // Query param filtering controlled by appConfig property\n        if (isFilterStrategy) {\n          retrieveParams.push(filters);\n        }\n      }\n\n      if (\n        appConfig.splitQueryParameterCalls ||\n        appConfig.enableGoogleCloudAdapter\n      ) {\n        retrieveParams.push(true); // Seperate SeriesInstanceUID filter calls.\n      }\n\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n        retrieveStudiesMetadata(...retrieveParams)\n      )\n        .then(result => {\n          if (result && !result.isCanceled) {\n            processStudies(result, filters);\n          }\n        })\n        .catch(error => {\n          if (error && !error.isCanceled) {\n            setError(error);\n            log.error(error);\n          }\n        });\n    } catch (error) {\n      if (error) {\n        setError(error);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = useCallback(() => {\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\n      }\n    }\n\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\n        deleteStudyMetadataPromise(studyInstanceUIDs);\n        studyMetadataManager.remove(studyInstanceUIDs);\n      }\n    }\n  });\n\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\n\n  useEffect(() => {\n    const hasStudyInstanceUIDsChanged = !(\n      prevStudyInstanceUIDs &&\n      prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e))\n    );\n\n    if (hasStudyInstanceUIDsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\n\n  useEffect(() => {\n    cancelableSeriesPromises = {};\n    cancelableStudiesPromises = {};\n    loadStudies();\n\n    return () => {\n      purgeCancellablePromises();\n    };\n  }, []);\n\n  if (error) {\n    const content = JSON.stringify(error);\n    if (content.includes('404') || content.includes('NOT_FOUND')) {\n      return <NotFound />;\n    }\n\n    return <NotFound message=\"Failed to retrieve study data\" />;\n  }\n\n  return (\n    <ConnectedViewer\n      studies={studies}\n      isStudyLoaded={isStudyLoaded}\n      studyInstanceUIDs={studyInstanceUIDs}\n    />\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUIDs: PropTypes.array.isRequired,\n  seriesInstanceUIDs: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n  setStudyData: PropTypes.func.isRequired,\n};\n\nexport default ViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\n\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n\n  return {\n    server: ownProps.server || activeServer,\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    setStudyData: (StudyInstanceUID, data) => {\n      dispatch(setStudyData(StudyInstanceUID, data));\n    },\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","import React, { useContext } from 'react';\nimport GoogleCloudApi from '../googleCloud/api/GoogleCloudApi';\nimport usePrevious from './usePrevious';\n\nimport * as GoogleCloudUtilServers from '../googleCloud/utils/getServers';\nimport { useSelector, useDispatch } from 'react-redux';\nimport isEqual from 'lodash.isequal';\n\n// Contexts\nimport AppContext from '../context/AppContext';\n\nconst getActiveServer = servers => {\n  const isActive = a => a.active === true;\n\n  return servers && servers.servers && servers.servers.find(isActive);\n};\n\nconst getServers = (appConfig, project, location, dataset, dicomStore) => {\n  let servers = [];\n  if (appConfig.enableGoogleCloudAdapter) {\n    GoogleCloudApi.urlBase = appConfig.healthcareApiEndpoint;\n    const pathUrl = GoogleCloudApi.getUrlBaseDicomWeb(\n      project,\n      location,\n      dataset,\n      dicomStore\n    );\n    const data = {\n      project,\n      location,\n      dataset,\n      dicomStore,\n      wadoUriRoot: pathUrl,\n      qidoRoot: pathUrl,\n      wadoRoot: pathUrl,\n    };\n    servers = GoogleCloudUtilServers.getServers(data, dicomStore);\n    if (!isValidServer(servers[0], appConfig)) {\n      return;\n    }\n  }\n\n  return servers;\n};\n\nconst isValidServer = (server, appConfig) => {\n  if (appConfig.enableGoogleCloudAdapter) {\n    return GoogleCloudUtilServers.isValidServer(server);\n  }\n\n  return !!server;\n};\n\nconst setServers = (dispatch, servers) => {\n  const action = {\n    type: 'SET_SERVERS',\n    servers,\n  };\n  dispatch(action);\n};\n\nconst useServerFromUrl = (\n  servers = [],\n  previousServers,\n  activeServer,\n  urlBasedServers,\n  appConfig,\n  project,\n  location,\n  dataset,\n  dicomStore\n) => {\n  // update state from url available only when gcloud on\n  if (!appConfig.enableGoogleCloudAdapter) {\n    return false;\n  }\n\n  const serverHasChanged = previousServers !== servers && previousServers;\n\n  // do not update from url. use state instead.\n  if (serverHasChanged) {\n    return false;\n  }\n\n  // if no valid urlbased servers\n  if (!urlBasedServers || !urlBasedServers.length) {\n    return false;\n  } else if (!servers.length || !activeServer) {\n    // no current valid server\n    return true;\n  }\n\n  const newServer = urlBasedServers[0];\n\n  let exists = servers.some(\n    GoogleCloudUtilServers.isEqualServer.bind(undefined, newServer)\n  );\n\n  return !exists;\n};\n\nexport default function useServer({\n  project,\n  location,\n  dataset,\n  dicomStore,\n} = {}) {\n  // Hooks\n  const servers = useSelector(state => state && state.servers);\n  const previousServers = usePrevious(servers);\n  const dispatch = useDispatch();\n\n  const { appConfig = {} } = useContext(AppContext);\n\n  const activeServer = getActiveServer(servers);\n  const urlBasedServers =\n    getServers(appConfig, project, location, dataset, dicomStore) || [];\n  const shouldUpdateServer = useServerFromUrl(\n    servers.servers,\n    previousServers,\n    activeServer,\n    urlBasedServers,\n    appConfig,\n    project,\n    location,\n    dataset,\n    dicomStore\n  );\n\n  if (shouldUpdateServer) {\n    setServers(dispatch, urlBasedServers);\n  } else if (isValidServer(activeServer, appConfig)) {\n    return activeServer;\n  }\n}\n","const getServers = (data, name) => {\n  const {\n    wadoUriRoot,\n    qidoRoot,\n    wadoRoot,\n    dataset = '',\n    dicomStore = '',\n    location = '',\n    project = '',\n  } = data;\n\n  return [\n    {\n      name: name,\n      dataset,\n      dicomStore,\n      location,\n      project,\n      imageRendering: 'wadors',\n      thumbnailRendering: 'wadors',\n      type: 'dicomWeb',\n      active: true,\n      wadoUriRoot,\n      qidoRoot,\n      wadoRoot,\n      supportsFuzzyMatching: false,\n      qidoSupportsIncludeField: false,\n    },\n  ];\n};\n\nconst isValidServer = server => {\n  return (\n    server &&\n    !!server.dataset &&\n    !!server.dicomStore &&\n    !!server.location &&\n    !!server.project\n  );\n};\n\nconst isEqualServer = (server = {}, toCompare = {}) => {\n  const serverLength = Object.keys(server).length;\n  const toCompareLength = Object.keys(toCompare).length;\n\n  if (!serverLength || !toCompareLength) {\n    return false;\n  }\n\n  return (\n    server.dataset === toCompare.dataset &&\n    server.dataset === toCompare.dataset &&\n    server.dicomStore === toCompare.dicomStore &&\n    server.location === toCompare.location &&\n    server.project === toCompare.project\n  );\n};\n\nexport { getServers, isValidServer, isEqualServer };\n","import { useLocation } from 'react-router-dom';\n\n/**\n * hook that builds on useLocation to parse\n * the query string for you.\n *\n * @name useQuery\n */\nexport default function() {\n  return new URLSearchParams(useLocation().search);\n}\n"],"sourceRoot":""}