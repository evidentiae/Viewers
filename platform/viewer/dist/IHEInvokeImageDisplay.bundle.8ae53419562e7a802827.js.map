{"version":3,"sources":["webpack:///./customHooks/usePrevious.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:///./routes/IHEInvokeImageDisplay.js"],"names":["usePrevious","value","ref","useRef","useEffect","current","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","utils","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_promoteStudyDisplaySet","list","values","searchMethod","listCopy","response","promotedCount","arrayValues","Object","keys","length","seriesInstanceUID","promotedResponse","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","split","forEach","index","findIndex","bind","undefined","itemToPromote","splice","data","displaySets","_isQueryParamApplied","applied","seriesInstanceUIDs","validateFilterApplied","arrayToInspect","every","item","some","seriesInstanceUIDStr","validatePromoteApplied","isValid","resultSeries","series","validateMethod","_showUserMessage","queryParamApplied","message","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","get","add","_updateStudyDisplaySets","console","log","createDisplaySets","_addDerivedDisplaySets","_thinStudyData","map","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","studyInstanceUIDs","clearViewportSpecificData","setStudyData","patientID","useState","error","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","Array","isArray","filter","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","loadStudies","retrieveParams","push","splitQueryParameterCalls","enableGoogleCloudAdapter","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","hasStudyInstanceUIDsChanged","e","includes","purge","content","JSON","stringify","NotFound","ConnectedViewer","propTypes","PropTypes","array","isRequired","object","func","OHIF","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","studyData","dispatch","UrlUtil","urlUtil","IHEInvokeImageDisplay","location","parse","search","requestType","studyUID","paramString","parseParam","shape","string","withRouter"],"mappings":"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","file":"IHEInvokeImageDisplay.bundle.8ae53419562e7a802827.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\n\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from './../App.js';\nimport { useSnackbarContext, ErrorPage } from '@ohif/ui';\n\n// Contexts\nimport AppContext from '../context/AppContext';\nimport NotFound from '../routes/NotFound';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, makeCancelable } = utils;\n\nconst _promoteToFront = (list, values, searchMethod) => {\n  let listCopy = [...list];\n  let response = [];\n  let promotedCount = 0;\n\n  const arrayValues = values.split(',');\n  arrayValues.forEach(value => {\n    const index = listCopy.findIndex(searchMethod.bind(undefined, value));\n\n    if (index >= 0) {\n      const [itemToPromote] = listCopy.splice(index, 1);\n      response[promotedCount] = itemToPromote;\n      promotedCount++;\n    }\n  });\n\n  return {\n    promoted: promotedCount === arrayValues.length,\n    data: [...response, ...listCopy],\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.SeriesInstanceUID === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n  let applied = true;\n  // skip in case no filter or no toast manager\n\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n  const seriesInstanceUIDs = seriesInstanceUID.split(',');\n\n  let validateFilterApplied = () => {\n    const sameSize = arrayToInspect.length === seriesInstanceUIDs.length;\n    if (!sameSize) {\n      return;\n    }\n\n    return arrayToInspect.every(item =>\n      seriesInstanceUIDs.some(\n        seriesInstanceUIDStr => seriesInstanceUIDStr === item.SeriesInstanceUID\n      )\n    );\n  };\n\n  let validatePromoteApplied = () => {\n    let isValid = true;\n    for (let index = 0; index < seriesInstanceUIDs.length; index++) {\n      const seriesInstanceUIDStr = seriesInstanceUIDs[index];\n      const resultSeries = arrayToInspect[index];\n\n      if (\n        !resultSeries ||\n        resultSeries.SeriesInstanceUID !== seriesInstanceUIDStr\n      ) {\n        isValid = false;\n        break;\n      }\n    }\n    return isValid;\n  };\n\n  const { series = [], displaySets = [] } = study;\n  const arrayToInspect = isFilterStrategy ? series : displaySets;\n  const validateMethod = isFilterStrategy\n    ? validateFilterApplied\n    : validatePromoteApplied;\n\n  if (!arrayToInspect) {\n    applied = false;\n  } else {\n    applied = validateMethod();\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => {} } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\n  if (existingSeries) {\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\n  } else {\n    studyMetadata.addSeries(seriesMetadata);\n  }\n\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata\n  );\n\n  study.displaySets = studyMetadata.getDisplaySets();\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\n    Modality: series.Modality,\n  });\n\n  _updateStudyMetadataManager(study, studyMetadata);\n};\n\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\n  const { StudyInstanceUID } = study;\n\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  console.log(\"_updateStudyDisplaySets\");\n  console.log(study);\n  console.log(studyMetadata);\n\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n    // returns [] for our layout study\n  }\n\n  if (study.derivedDisplaySets) {\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\n  }\n};\n\nconst _thinStudyData = study => {\n  return {\n    StudyInstanceUID: study.StudyInstanceUID,\n    series: study.series.map(item => ({\n      SeriesInstanceUID: item.SeriesInstanceUID,\n    })),\n  };\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUIDs,\n  seriesInstanceUIDs,\n  clearViewportSpecificData,\n  setStudyData,\n  patientID\n}) {\n  // hooks\n  const [error, setError] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const {\n    filterQueryParam: isFilterStrategy = false,\n    maxConcurrentMetadataRequests,\n  } = appConfig;\n\n  console.log(\"ViewerRetrieveStudyData()\");\n  console.log(studyInstanceUIDs);\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not totally applied. It might be using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n    setIsStudyLoaded(true);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filters.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters) => {\n    console.log(\"processStudies\");\n    console.log(studiesData);\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studiesData_ = studiesData.filter(study => study !== null);\n      const studies = studiesData_.map(study => {\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.StudyInstanceUID\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateStudyMetadataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\n          loadRemainingSeries(studyMetadata)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(error);\n              log.error(error);\n            }\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const forceRerender = () => setStudies(studies => [...studies]);\n\n  const loadRemainingSeries = async studyMetadata => {\n    const { seriesLoader } = studyMetadata.getData();\n    if (!seriesLoader) return;\n\n    const loadNextSeries = async () => {\n      if (!seriesLoader.hasNext()) return;\n      const series = await seriesLoader.next();\n      _addSeriesToStudy(studyMetadata, series);\n      forceRerender();\n      return loadNextSeries();\n    };\n\n    const concurrentRequestsAllowed =\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\n    const promises = Array(concurrentRequestsAllowed)\n      .fill(null)\n      .map(loadNextSeries);\n\n    return await Promise.all(promises);\n  };\n\n  const loadStudies = async () => {\n    console.log(\"loadStudies()\");\n    try {\n      const filters = {};\n      // Use the first, discard others\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\n      const retrieveParams = [server, studyInstanceUIDs];\n\n      if (seriesInstanceUID) {\n        filters.seriesInstanceUID = seriesInstanceUID;\n        // Query param filtering controlled by appConfig property\n        if (isFilterStrategy) {\n          retrieveParams.push(filters);\n        }\n      }\n\n      if (\n        appConfig.splitQueryParameterCalls ||\n        appConfig.enableGoogleCloudAdapter\n      ) {\n        retrieveParams.push(true); // Seperate SeriesInstanceUID filter calls.\n      }\n\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n        retrieveStudiesMetadata(...retrieveParams)\n      )\n        .then(result => {\n          if (result && !result.isCanceled) {\n            processStudies(result, filters);\n          }\n        })\n        .catch(error => {\n          if (error && !error.isCanceled) {\n            setError(error);\n            log.error(error);\n          }\n        });\n    } catch (error) {\n      if (error) {\n        setError(error);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = useCallback(() => {\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\n      }\n    }\n\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\n        deleteStudyMetadataPromise(studyInstanceUIDs);\n        studyMetadataManager.remove(studyInstanceUIDs);\n      }\n    }\n  });\n\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\n  const hasStudyInstanceUIDsChanged = !(\n    prevStudyInstanceUIDs &&\n    prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e)) &&\n    studyInstanceUIDs.every(e => prevStudyInstanceUIDs.includes(e))\n  );\n\n  useEffect(() => {\n    if (hasStudyInstanceUIDsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\n\n  useEffect(() => {\n    if (hasStudyInstanceUIDsChanged) {\n      cancelableSeriesPromises = {};\n      cancelableStudiesPromises = {};\n      loadStudies();\n      return () => {\n        purgeCancellablePromises();\n      };\n    }\n  }, [studyInstanceUIDs]);\n\n  if (error) {\n    const content = JSON.stringify(error);\n    if (content.includes('404') || content.includes('NOT_FOUND')) {\n      return <NotFound />;\n    }\n\n    return <NotFound message=\"Failed to retrieve study data\" />;\n  }\n\n  return (\n    <ConnectedViewer\n      studies={studies}\n      isStudyLoaded={isStudyLoaded}\n      studyInstanceUIDs={studyInstanceUIDs}\n      patientID={patientID}\n    />\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUIDs: PropTypes.array.isRequired,\n  seriesInstanceUIDs: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n  setStudyData: PropTypes.func.isRequired,\n};\n\nexport default ViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\n\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n  console.log(\"mapStateToProps for ConnectedViewerRetrieveStudyData\");\n  console.log(state.studies.studyData);\n  const studyInstanceUIDs = Object.keys(state.studies.studyData);\n\n  return {\n    server: ownProps.server || activeServer,\n    studyInstanceUIDs: studyInstanceUIDs\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    setStudyData: (StudyInstanceUID, data) => {\n      dispatch(setStudyData(StudyInstanceUID, data));\n    },\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { withRouter } from 'react-router-dom';\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\nconst { urlUtil: UrlUtil } = OHIF.utils;\n\nfunction IHEInvokeImageDisplay({ location }) {\n  const {\n    // patientID,\n    requestType,\n    studyUID,\n  } = UrlUtil.parse(location.search);\n\n  switch (requestType) {\n    case 'STUDY':\n      return (\n        <ConnectedViewerRetrieveStudyData\n          studyInstanceUIDs={studyUID.split(';')}\n        />\n      );\n\n    case 'STUDYBASE64':\n      return (\n        <ConnectedViewerRetrieveStudyData\n          studyInstanceUIDs={UrlUtil.paramString.parseParam(studyUID)}\n        />\n      );\n\n    case 'PATIENT':\n      // TODO: connect this to the StudyList when we have the filter parameters set up\n      // return <StudyList patientUIDs={patientID.split(';')} />;\n      return '';\n\n    default:\n      // TODO: Figure out what to do here, this won't work because StudyList expects studies\n      // return <StudyList />;\n      return '';\n  }\n}\n\nIHEInvokeImageDisplay.propTypes = {\n  location: PropTypes.shape({\n    search: PropTypes.string,\n  }).isRequired,\n};\n\nexport default withRouter(IHEInvokeImageDisplay);\n"],"sourceRoot":""}