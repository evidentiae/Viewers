{"version":3,"sources":["webpack:///./customHooks/usePrevious.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:////home/david/dev/evs/viewers-clean/node_modules/querystring-es3/index.js","webpack:////home/david/dev/evs/viewers-clean/node_modules/querystring-es3/decode.js","webpack:////home/david/dev/evs/viewers-clean/node_modules/querystring-es3/encode.js","webpack:///./routes/StandaloneRouting.js","webpack:///./connectedComponents/ConnectedStandaloneRouting.js"],"names":["usePrevious","value","ref","useRef","useEffect","current","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","utils","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_promoteStudyDisplaySet","list","values","searchMethod","listCopy","response","promotedCount","arrayValues","Object","keys","length","seriesInstanceUID","promotedResponse","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","split","forEach","index","findIndex","bind","undefined","itemToPromote","splice","data","displaySets","_isQueryParamApplied","applied","seriesInstanceUIDs","validateFilterApplied","arrayToInspect","every","item","some","seriesInstanceUIDStr","validatePromoteApplied","isValid","resultSeries","series","validateMethod","_showUserMessage","queryParamApplied","message","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","get","add","_updateStudyDisplaySets","createDisplaySets","_addDerivedDisplaySets","_thinStudyData","map","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","studyInstanceUIDs","clearViewportSpecificData","setStudyData","useState","error","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","Array","isArray","filter","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","log","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","loadStudies","retrieveParams","push","splitQueryParameterCalls","enableGoogleCloudAdapter","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","e","includes","purge","JSON","stringify","ConnectedViewer","propTypes","PropTypes","array","isRequired","object","func","OHIF","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","dispatch","exports","decode","parse","encode","hasOwnProperty","obj","prop","prototype","call","module","qs","sep","eq","options","regexp","maxKeys","len","i","kstr","vstr","k","v","x","replace","idx","indexOf","substr","decodeURIComponent","xs","toString","stringifyPrimitive","isFinite","name","objectKeys","ks","encodeURIComponent","join","f","res","key","StandaloneRouting","loading","query","resolve","reject","url","Error","oReq","XMLHttpRequest","addEventListener","warn","event","target","status","responseText","info","dicomWeb","type","props","activateServer","metadataProvider","cornerstone","instances","instance","imageId","naturalizedDicom","addInstance","addImageIdToUIDs","SOPInstanceUID","open","setRequestHeader","send","search","this","location","slice","parseQueryAndRetrieveDICOMWebData","_mapStudiesToNewFormat","updatedStudies","updatedStudiesInstanceUIDs","setState","NotFound","showGoBackButton","Component","store","setServers","uniqueStudyUIDs","Set","from","ConnectedStandaloneRouting"],"mappings":"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","file":"ConnectedStandaloneRouting.bundle.6717bf5d3b68ca432733.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\n\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from './../App.js';\nimport { useSnackbarContext } from '@ohif/ui';\n\n// Contexts\nimport AppContext from '../context/AppContext';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, makeCancelable } = utils;\n\nconst _promoteToFront = (list, values, searchMethod) => {\n  let listCopy = [...list];\n  let response = [];\n  let promotedCount = 0;\n\n  const arrayValues = values.split(',');\n  arrayValues.forEach(value => {\n    const index = listCopy.findIndex(searchMethod.bind(undefined, value));\n\n    if (index >= 0) {\n      const [itemToPromote] = listCopy.splice(index, 1);\n      response[promotedCount] = itemToPromote;\n      promotedCount++;\n    }\n  });\n\n  return {\n    promoted: promotedCount === arrayValues.length,\n    data: [...response, ...listCopy],\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.SeriesInstanceUID === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n  let applied = true;\n  // skip in case no filter or no toast manager\n\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n  const seriesInstanceUIDs = seriesInstanceUID.split(',');\n\n  let validateFilterApplied = () => {\n    const sameSize = arrayToInspect.length === seriesInstanceUIDs.length;\n    if (!sameSize) {\n      return;\n    }\n\n    return arrayToInspect.every(item =>\n      seriesInstanceUIDs.some(\n        seriesInstanceUIDStr => seriesInstanceUIDStr === item.SeriesInstanceUID\n      )\n    );\n  };\n\n  let validatePromoteApplied = () => {\n    let isValid = true;\n    for (let index = 0; index < seriesInstanceUIDs.length; index++) {\n      const seriesInstanceUIDStr = seriesInstanceUIDs[index];\n      const resultSeries = arrayToInspect[index];\n\n      if (\n        !resultSeries ||\n        resultSeries.SeriesInstanceUID !== seriesInstanceUIDStr\n      ) {\n        isValid = false;\n        break;\n      }\n    }\n    return isValid;\n  };\n\n  const { series = [], displaySets = [] } = study;\n  const arrayToInspect = isFilterStrategy ? series : displaySets;\n  const validateMethod = isFilterStrategy\n    ? validateFilterApplied\n    : validatePromoteApplied;\n\n  if (!arrayToInspect) {\n    applied = false;\n  } else {\n    applied = validateMethod();\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => {} } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\n  if (existingSeries) {\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\n  } else {\n    studyMetadata.addSeries(seriesMetadata);\n  }\n\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata\n  );\n\n  study.displaySets = studyMetadata.getDisplaySets();\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\n    Modality: series.Modality,\n  });\n\n  _updateStudyMetadataManager(study, studyMetadata);\n};\n\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\n  const { StudyInstanceUID } = study;\n\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n  }\n\n  if (study.derivedDisplaySets) {\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\n  }\n};\n\nconst _thinStudyData = study => {\n  return {\n    StudyInstanceUID: study.StudyInstanceUID,\n    series: study.series.map(item => ({\n      SeriesInstanceUID: item.SeriesInstanceUID,\n    })),\n  };\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUIDs,\n  seriesInstanceUIDs,\n  clearViewportSpecificData,\n  setStudyData,\n}) {\n  // hooks\n  const [error, setError] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const {\n    filterQueryParam: isFilterStrategy = false,\n    maxConcurrentMetadataRequests,\n  } = appConfig;\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not totally applied. It might be using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n    setIsStudyLoaded(true);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filters.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters) => {\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studiesData_ = studiesData.filter(study => study !== null);\n      const studies = studiesData_.map(study => {\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.StudyInstanceUID\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateStudyMetadataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\n          loadRemainingSeries(studyMetadata)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(true);\n              log.error(error);\n            }\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const forceRerender = () => setStudies(studies => [...studies]);\n\n  const loadRemainingSeries = async studyMetadata => {\n    const { seriesLoader } = studyMetadata.getData();\n    if (!seriesLoader) return;\n\n    const loadNextSeries = async () => {\n      if (!seriesLoader.hasNext()) return;\n      const series = await seriesLoader.next();\n      _addSeriesToStudy(studyMetadata, series);\n      forceRerender();\n      return loadNextSeries();\n    };\n\n    const concurrentRequestsAllowed =\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\n    const promises = Array(concurrentRequestsAllowed)\n      .fill(null)\n      .map(loadNextSeries);\n\n    return await Promise.all(promises);\n  };\n\n  const loadStudies = async () => {\n    try {\n      const filters = {};\n      // Use the first, discard others\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\n      const retrieveParams = [server, studyInstanceUIDs];\n\n      if (seriesInstanceUID) {\n        filters.seriesInstanceUID = seriesInstanceUID;\n        // Query param filtering controlled by appConfig property\n        if (isFilterStrategy) {\n          retrieveParams.push(filters);\n        }\n      }\n\n      if (\n        appConfig.splitQueryParameterCalls ||\n        appConfig.enableGoogleCloudAdapter\n      ) {\n        retrieveParams.push(true); // Seperate SeriesInstanceUID filter calls.\n      }\n\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n        retrieveStudiesMetadata(...retrieveParams)\n      )\n        .then(result => {\n          if (result && !result.isCanceled) {\n            processStudies(result, filters);\n          }\n        })\n        .catch(error => {\n          if (error && !error.isCanceled) {\n            setError(true);\n            log.error(error);\n          }\n        });\n    } catch (error) {\n      if (error) {\n        setError(true);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = useCallback(() => {\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\n      }\n    }\n\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\n        deleteStudyMetadataPromise(studyInstanceUIDs);\n        studyMetadataManager.remove(studyInstanceUIDs);\n      }\n    }\n  });\n\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\n\n  useEffect(() => {\n    const hasStudyInstanceUIDsChanged = !(\n      prevStudyInstanceUIDs &&\n      prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e))\n    );\n\n    if (hasStudyInstanceUIDsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\n\n  useEffect(() => {\n    cancelableSeriesPromises = {};\n    cancelableStudiesPromises = {};\n    loadStudies();\n\n    return () => {\n      purgeCancellablePromises();\n    };\n  }, []);\n\n  if (error) {\n    return <div>Error: {JSON.stringify(error)}</div>;\n  }\n\n  return (\n    <ConnectedViewer\n      studies={studies}\n      isStudyLoaded={isStudyLoaded}\n      studyInstanceUIDs={studyInstanceUIDs}\n    />\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUIDs: PropTypes.array.isRequired,\n  seriesInstanceUIDs: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n  setStudyData: PropTypes.func.isRequired,\n};\n\nexport default ViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\n\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n\n  return {\n    server: ownProps.server || activeServer,\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    setStudyData: (StudyInstanceUID, data) => {\n      dispatch(setStudyData(StudyInstanceUID, data));\n    },\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","import React, { Component } from 'react';\nimport OHIF from '@ohif/core';\nimport PropTypes from 'prop-types';\nimport qs from 'querystring';\n\nimport { extensionManager } from './../App.js';\nimport ConnectedViewer from '../connectedComponents/ConnectedViewer';\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData';\nimport NotFound from '../routes/NotFound';\n\nconst { log, metadata, utils } = OHIF;\nconst { studyMetadataManager } = utils;\nconst { OHIFStudyMetadata } = metadata;\n\nclass StandaloneRouting extends Component {\n  state = {\n    studies: null,\n    server: null,\n    studyInstanceUIDs: null,\n    seriesInstanceUIDs: null,\n    error: null,\n    loading: true,\n  };\n\n  static propTypes = {\n    location: PropTypes.object,\n    store: PropTypes.object,\n    setServers: PropTypes.func,\n  };\n\n  parseQueryAndRetrieveDICOMWebData(query) {\n    return new Promise((resolve, reject) => {\n      const url = query.url;\n\n      if (!url) {\n        return reject(new Error('No URL was specified. Use ?url=$yourURL'));\n      }\n\n      // Define a request to the server to retrieve the study data\n      // as JSON, given a URL that was in the Route\n      const oReq = new XMLHttpRequest();\n\n      // Add event listeners for request failure\n      oReq.addEventListener('error', error => {\n        log.warn('An error occurred while retrieving the JSON data');\n        reject(error);\n      });\n\n      // When the JSON has been returned, parse it into a JavaScript Object\n      // and render the OHIF Viewer with this data\n      oReq.addEventListener('load', event => {\n        if (event.target.status === 404) {\n          reject(new Error('No JSON data found'));\n        }\n\n        // Parse the response content\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText\n        if (!oReq.responseText) {\n          log.warn('Response was undefined');\n          reject(new Error('Response was undefined'));\n        }\n\n        log.info(JSON.stringify(oReq.responseText, null, 2));\n\n        const data = JSON.parse(oReq.responseText);\n        if (data.servers) {\n          if (!query.studyInstanceUIDs) {\n            log.warn('No study instance uids specified');\n            reject(new Error('No study instance uids specified'));\n          }\n\n          const server = data.servers.dicomWeb[0];\n          server.type = 'dicomWeb';\n\n          log.warn('Activating server', server);\n          this.props.activateServer(server);\n\n          const studyInstanceUIDs = query.studyInstanceUIDs.split(';');\n          const seriesInstanceUIDs = query.seriesInstanceUIDs\n            ? query.seriesInstanceUIDs.split(';')\n            : [];\n\n          resolve({ server, studyInstanceUIDs, seriesInstanceUIDs });\n        } else {\n          // Parse data here and add to metadata provider.\n          const metadataProvider = OHIF.cornerstone.metadataProvider;\n\n          let StudyInstanceUID;\n          let SeriesInstanceUID;\n\n          data.studies.forEach(study => {\n            StudyInstanceUID = study.StudyInstanceUID;\n\n            study.series.forEach(series => {\n              SeriesInstanceUID = series.SeriesInstanceUID;\n\n              series.instances.forEach(instance => {\n                const { url: imageId, metadata: naturalizedDicom } = instance;\n\n                // Add instance to metadata provider.\n                metadataProvider.addInstance(naturalizedDicom);\n                // Add imageId specific mapping to this data as the URL isn't necessarliy WADO-URI.\n                metadataProvider.addImageIdToUIDs(imageId, {\n                  StudyInstanceUID,\n                  SeriesInstanceUID,\n                  SOPInstanceUID: naturalizedDicom.SOPInstanceUID,\n                });\n              });\n            });\n          });\n\n          resolve({ studies: data.studies, studyInstanceUIDs: [] });\n        }\n      });\n\n      // Open the Request to the server for the JSON data\n      // In this case we have a server-side route called /api/\n      // which responds to GET requests with the study data\n      log.info(`Sending Request to: ${url}`);\n      oReq.open('GET', url);\n      oReq.setRequestHeader('Accept', 'application/json');\n\n      // Fire the request to the server\n      oReq.send();\n    });\n  }\n\n  async componentDidMount() {\n    try {\n      let { search } = this.props.location;\n\n      // Remove ? prefix which is included for some reason\n      search = search.slice(1, search.length);\n      const query = qs.parse(search);\n\n      let {\n        server,\n        studies,\n        studyInstanceUIDs,\n        seriesInstanceUIDs,\n      } = await this.parseQueryAndRetrieveDICOMWebData(query);\n\n      if (studies) {\n        const {\n          studies: updatedStudies,\n          studyInstanceUIDs: updatedStudiesInstanceUIDs,\n        } = _mapStudiesToNewFormat(studies);\n        studies = updatedStudies;\n        studyInstanceUIDs = updatedStudiesInstanceUIDs;\n      }\n\n      this.setState({\n        studies,\n        server,\n        studyInstanceUIDs,\n        seriesInstanceUIDs,\n        loading: false,\n      });\n    } catch (error) {\n      this.setState({ error: error.message, loading: false });\n    }\n  }\n\n  render() {\n    const message = this.state.error\n      ? `Error: ${JSON.stringify(this.state.error)}`\n      : 'Loading...';\n    if (this.state.error || this.state.loading) {\n      return <NotFound message={message} showGoBackButton={this.state.error} />;\n    }\n\n    return this.state.studies ? (\n      <ConnectedViewer studies={this.state.studies} />\n    ) : (\n      <ConnectedViewerRetrieveStudyData\n        studyInstanceUIDs={this.state.studyInstanceUIDs}\n        seriesInstanceUIDs={this.state.seriesInstanceUIDs}\n        server={this.state.server}\n      />\n    );\n  }\n}\n\nconst _mapStudiesToNewFormat = studies => {\n  studyMetadataManager.purge();\n\n  /* Map studies to new format, update metadata manager? */\n  const uniqueStudyUIDs = new Set();\n  const updatedStudies = studies.map(study => {\n    const studyMetadata = new OHIFStudyMetadata(study, study.StudyInstanceUID);\n\n    const sopClassHandlerModules =\n      extensionManager.modules['sopClassHandlerModule'];\n    study.displaySets =\n      study.displaySets ||\n      studyMetadata.createDisplaySets(sopClassHandlerModules);\n\n    studyMetadataManager.add(studyMetadata);\n    uniqueStudyUIDs.add(study.StudyInstanceUID);\n\n    return study;\n  });\n\n  return {\n    studies: updatedStudies,\n    studyInstanceUIDs: Array.from(uniqueStudyUIDs),\n  };\n};\n\nexport default StandaloneRouting;\n","import { connect } from 'react-redux';\nimport StandaloneRouting from '../routes/StandaloneRouting';\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    activateServer: server => {\n      const action = {\n        type: 'ACTIVATE_SERVER',\n        server,\n      };\n      dispatch(action);\n    },\n  };\n};\n\nconst ConnectedStandaloneRouting = connect(\n  null,\n  mapDispatchToProps\n)(StandaloneRouting);\n\nexport default ConnectedStandaloneRouting;\n"],"sourceRoot":""}