{"version":3,"sources":["webpack:///./customHooks/usePrevious.js","webpack:///./connectedComponents/ViewerRetrieveStudyData.js","webpack:///./connectedComponents/ConnectedViewerRetrieveStudyData.js","webpack:////home/david/dev/evs/viewer/ohif/node_modules/querystring-es3/index.js","webpack:////home/david/dev/evs/viewer/ohif/node_modules/querystring-es3/decode.js","webpack:////home/david/dev/evs/viewer/ohif/node_modules/querystring-es3/encode.js","webpack:///./routes/StandaloneRouting.js","webpack:///./connectedComponents/ConnectedStandaloneRouting.js"],"names":["usePrevious","value","ref","useRef","useEffect","current","OHIFStudyMetadata","metadata","OHIFSeriesMetadata","retrieveStudiesMetadata","studies","deleteStudyMetadataPromise","studyMetadataManager","utils","makeCancelable","_promoteList","study","studyMetadata","filters","isFilterStrategy","promoted","_promoteStudyDisplaySet","list","values","searchMethod","listCopy","response","promotedCount","arrayValues","Object","keys","length","seriesInstanceUID","promotedResponse","getDisplaySets","valueToCompare","displaySet","SeriesInstanceUID","split","forEach","index","findIndex","bind","undefined","itemToPromote","splice","data","displaySets","_isQueryParamApplied","applied","seriesInstanceUIDs","validateFilterApplied","arrayToInspect","every","item","some","seriesInstanceUIDStr","validatePromoteApplied","isValid","resultSeries","series","validateMethod","_showUserMessage","queryParamApplied","message","dialog","show","showUserMessage","_addSeriesToStudy","sopClassHandlerModules","extensionManager","modules","getData","seriesMetadata","getSeriesByUID","updateSeries","addSeries","createAndAddDisplaySetsForSeries","derivedDisplaySets","getDerivedDatasets","Modality","_updateStudyMetadataManager","StudyInstanceUID","get","add","_updateStudyDisplaySets","console","log","createDisplaySets","_addDerivedDisplaySets","_thinStudyData","map","ViewerRetrieveStudyData","cancelableSeriesPromises","cancelableStudiesPromises","server","studyInstanceUIDs","clearViewportSpecificData","setStudyData","patientID","useState","error","setError","setStudies","isStudyLoaded","setIsStudyLoaded","snackbarContext","useSnackbarContext","useContext","AppContext","appConfig","filterQueryParam","maxConcurrentMetadataRequests","processStudies","studiesData","Array","isArray","filter","loadRemainingSeries","then","result","isCanceled","isQueryParamApplied","studyDidLoad","catch","seriesLoader","loadNextSeries","hasNext","next","concurrentRequestsAllowed","getSeriesCount","promises","fill","Promise","all","loadStudies","retrieveParams","push","splitQueryParameterCalls","enableGoogleCloudAdapter","purgeCancellablePromises","useCallback","cancel","remove","prevStudyInstanceUIDs","hasStudyInstanceUIDsChanged","e","includes","purge","content","JSON","stringify","NotFound","ConnectedViewer","propTypes","PropTypes","array","isRequired","object","func","OHIF","redux","actions","isActive","a","active","ConnectedViewerRetrieveStudyData","connect","state","ownProps","activeServer","servers","find","studyData","dispatch","exports","decode","parse","encode","hasOwnProperty","obj","prop","prototype","call","module","qs","sep","eq","options","regexp","maxKeys","len","i","kstr","vstr","k","v","x","replace","idx","indexOf","substr","decodeURIComponent","xs","toString","stringifyPrimitive","isFinite","name","objectKeys","ks","encodeURIComponent","join","f","res","key","StandaloneRouting","loading","query","resolve","reject","url","Error","oReq","XMLHttpRequest","addEventListener","warn","event","target","status","responseText","info","dicomWeb","type","props","activateServer","metadataProvider","cornerstone","instances","instance","imageId","naturalizedDicom","addInstance","addImageIdToUIDs","SOPInstanceUID","open","setRequestHeader","send","search","this","location","slice","parseQueryAndRetrieveDICOMWebData","_mapStudiesToNewFormat","updatedStudies","updatedStudiesInstanceUIDs","setState","showGoBackButton","Component","store","setServers","uniqueStudyUIDs","Set","from","ConnectedStandaloneRouting"],"mappings":"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","file":"ConnectedStandaloneRouting.bundle.42dda451ef88cf043f41.js","sourcesContent":["import React, { useEffect, useRef } from 'react';\nexport default function usePrevious(value) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref.current;\n}\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\nimport { metadata, studies, utils, log } from '@ohif/core';\nimport usePrevious from '../customHooks/usePrevious';\n\nimport ConnectedViewer from './ConnectedViewer.js';\nimport PropTypes from 'prop-types';\nimport { extensionManager } from './../App.js';\nimport { useSnackbarContext, ErrorPage } from '@ohif/ui';\n\n// Contexts\nimport AppContext from '../context/AppContext';\nimport NotFound from '../routes/NotFound';\n\nconst { OHIFStudyMetadata, OHIFSeriesMetadata } = metadata;\nconst { retrieveStudiesMetadata, deleteStudyMetadataPromise } = studies;\nconst { studyMetadataManager, makeCancelable } = utils;\n\nconst _promoteToFront = (list, values, searchMethod) => {\n  let listCopy = [...list];\n  let response = [];\n  let promotedCount = 0;\n\n  const arrayValues = values.split(',');\n  arrayValues.forEach(value => {\n    const index = listCopy.findIndex(searchMethod.bind(undefined, value));\n\n    if (index >= 0) {\n      const [itemToPromote] = listCopy.splice(index, 1);\n      response[promotedCount] = itemToPromote;\n      promotedCount++;\n    }\n  });\n\n  return {\n    promoted: promotedCount === arrayValues.length,\n    data: [...response, ...listCopy],\n  };\n};\n\n/**\n * Promote series to front if find found equivalent on filters object\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _promoteList = (study, studyMetadata, filters, isFilterStrategy) => {\n  let promoted = false;\n  // Promote only if no filter should be applied\n  if (!isFilterStrategy) {\n    promoted = _promoteStudyDisplaySet(study, studyMetadata, filters);\n  }\n\n  return promoted;\n};\n\nconst _promoteStudyDisplaySet = (study, studyMetadata, filters) => {\n  let promoted = false;\n  const queryParamsLength = Object.keys(filters).length;\n  const shouldPromoteToFront = queryParamsLength > 0;\n\n  if (shouldPromoteToFront) {\n    const { seriesInstanceUID } = filters;\n\n    const _seriesLookup = (valueToCompare, displaySet) => {\n      return displaySet.SeriesInstanceUID === valueToCompare;\n    };\n    const promotedResponse = _promoteToFront(\n      studyMetadata.getDisplaySets(),\n      seriesInstanceUID,\n      _seriesLookup\n    );\n\n    study.displaySets = promotedResponse.data;\n    promoted = promotedResponse.promoted;\n  }\n\n  return promoted;\n};\n\n/**\n * Method to identify if query param (from url) was applied to given list\n * @param {Object} study - study reference to promote series against\n * @param {Object} [filters] - Object containing filters to be applied\n * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n * @param {boolean} isFilterStrategy - if filtering by query param strategy ON\n */\nconst _isQueryParamApplied = (study, filters = {}, isFilterStrategy) => {\n  const { seriesInstanceUID } = filters;\n  let applied = true;\n  // skip in case no filter or no toast manager\n\n  if (!seriesInstanceUID) {\n    return applied;\n  }\n  const seriesInstanceUIDs = seriesInstanceUID.split(',');\n\n  let validateFilterApplied = () => {\n    const sameSize = arrayToInspect.length === seriesInstanceUIDs.length;\n    if (!sameSize) {\n      return;\n    }\n\n    return arrayToInspect.every(item =>\n      seriesInstanceUIDs.some(\n        seriesInstanceUIDStr => seriesInstanceUIDStr === item.SeriesInstanceUID\n      )\n    );\n  };\n\n  let validatePromoteApplied = () => {\n    let isValid = true;\n    for (let index = 0; index < seriesInstanceUIDs.length; index++) {\n      const seriesInstanceUIDStr = seriesInstanceUIDs[index];\n      const resultSeries = arrayToInspect[index];\n\n      if (\n        !resultSeries ||\n        resultSeries.SeriesInstanceUID !== seriesInstanceUIDStr\n      ) {\n        isValid = false;\n        break;\n      }\n    }\n    return isValid;\n  };\n\n  const { series = [], displaySets = [] } = study;\n  const arrayToInspect = isFilterStrategy ? series : displaySets;\n  const validateMethod = isFilterStrategy\n    ? validateFilterApplied\n    : validatePromoteApplied;\n\n  if (!arrayToInspect) {\n    applied = false;\n  } else {\n    applied = validateMethod();\n  }\n\n  return applied;\n};\nconst _showUserMessage = (queryParamApplied, message, dialog = {}) => {\n  if (queryParamApplied) {\n    return;\n  }\n\n  const { show: showUserMessage = () => {} } = dialog;\n  showUserMessage({\n    message,\n  });\n};\n\nconst _addSeriesToStudy = (studyMetadata, series) => {\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n  const study = studyMetadata.getData();\n  const seriesMetadata = new OHIFSeriesMetadata(series, study);\n  const existingSeries = studyMetadata.getSeriesByUID(series.SeriesInstanceUID);\n  if (existingSeries) {\n    studyMetadata.updateSeries(series.SeriesInstanceUID, seriesMetadata);\n  } else {\n    studyMetadata.addSeries(seriesMetadata);\n  }\n\n  studyMetadata.createAndAddDisplaySetsForSeries(\n    sopClassHandlerModules,\n    seriesMetadata\n  );\n\n  study.displaySets = studyMetadata.getDisplaySets();\n  study.derivedDisplaySets = studyMetadata.getDerivedDatasets({\n    Modality: series.Modality,\n  });\n\n  _updateStudyMetadataManager(study, studyMetadata);\n};\n\nconst _updateStudyMetadataManager = (study, studyMetadata) => {\n  const { StudyInstanceUID } = study;\n\n  if (!studyMetadataManager.get(StudyInstanceUID)) {\n    studyMetadataManager.add(studyMetadata);\n  }\n};\n\nconst _updateStudyDisplaySets = (study, studyMetadata) => {\n  console.log(\"_updateStudyDisplaySets\");\n  console.log(study);\n  console.log(studyMetadata);\n\n  const sopClassHandlerModules =\n    extensionManager.modules['sopClassHandlerModule'];\n\n  if (!study.displaySets) {\n    study.displaySets = studyMetadata.createDisplaySets(sopClassHandlerModules);\n    // returns [] for our layout study\n  }\n\n  if (study.derivedDisplaySets) {\n    studyMetadata._addDerivedDisplaySets(study.derivedDisplaySets);\n  }\n};\n\nconst _thinStudyData = study => {\n  return {\n    StudyInstanceUID: study.StudyInstanceUID,\n    series: study.series.map(item => ({\n      SeriesInstanceUID: item.SeriesInstanceUID,\n    })),\n  };\n};\n\nfunction ViewerRetrieveStudyData({\n  server,\n  studyInstanceUIDs,\n  seriesInstanceUIDs,\n  clearViewportSpecificData,\n  setStudyData,\n  patientID\n}) {\n  // hooks\n  const [error, setError] = useState(false);\n  const [studies, setStudies] = useState([]);\n  const [isStudyLoaded, setIsStudyLoaded] = useState(false);\n  const snackbarContext = useSnackbarContext();\n  const { appConfig = {} } = useContext(AppContext);\n  const {\n    filterQueryParam: isFilterStrategy = false,\n    maxConcurrentMetadataRequests,\n  } = appConfig;\n\n  console.log(\"ViewerRetrieveStudyData()\");\n  console.log(studyInstanceUIDs);\n\n  let cancelableSeriesPromises;\n  let cancelableStudiesPromises;\n  /**\n   * Callback method when study is totally loaded\n   * @param {object} study study loaded\n   * @param {object} studyMetadata studyMetadata for given study\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filter.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const studyDidLoad = (study, studyMetadata, filters) => {\n    // User message\n    const promoted = _promoteList(\n      study,\n      studyMetadata,\n      filters,\n      isFilterStrategy\n    );\n\n    // Clear viewport to allow new promoted one to be displayed\n    if (promoted) {\n      clearViewportSpecificData(0);\n    }\n\n    const isQueryParamApplied = _isQueryParamApplied(\n      study,\n      filters,\n      isFilterStrategy\n    );\n    // Show message in case not promoted neither filtered but should to\n    _showUserMessage(\n      isQueryParamApplied,\n      'Query parameters were not totally applied. It might be using original series list for given study.',\n      snackbarContext\n    );\n\n    setStudies([...studies, study]);\n    setIsStudyLoaded(true);\n  };\n\n  /**\n   * Method to process studies. It will update displaySet, studyMetadata, load remaining series, ...\n   * @param {Array} studiesData Array of studies retrieved from server\n   * @param {Object} [filters] - Object containing filters to be applied\n   * @param {string} [filters.seriesInstanceUID] - series instance uid to filter results against\n   */\n  const processStudies = (studiesData, filters) => {\n    console.log(\"processStudies\");\n    console.log(studiesData);\n    if (Array.isArray(studiesData) && studiesData.length > 0) {\n      // Map studies to new format, update metadata manager?\n      const studiesData_ = studiesData.filter(study => study !== null);\n      const studies = studiesData_.map(study => {\n        setStudyData(study.StudyInstanceUID, _thinStudyData(study));\n        const studyMetadata = new OHIFStudyMetadata(\n          study,\n          study.StudyInstanceUID\n        );\n\n        _updateStudyDisplaySets(study, studyMetadata);\n        _updateStudyMetadataManager(study, studyMetadata);\n\n        // Attempt to load remaning series if any\n        cancelableSeriesPromises[study.StudyInstanceUID] = makeCancelable(\n          loadRemainingSeries(studyMetadata)\n        )\n          .then(result => {\n            if (result && !result.isCanceled) {\n              studyDidLoad(study, studyMetadata, filters);\n            }\n          })\n          .catch(error => {\n            if (error && !error.isCanceled) {\n              setError(error);\n              log.error(error);\n            }\n          });\n\n        return study;\n      });\n\n      setStudies(studies);\n    }\n  };\n\n  const forceRerender = () => setStudies(studies => [...studies]);\n\n  const loadRemainingSeries = async studyMetadata => {\n    const { seriesLoader } = studyMetadata.getData();\n    if (!seriesLoader) return;\n\n    const loadNextSeries = async () => {\n      if (!seriesLoader.hasNext()) return;\n      const series = await seriesLoader.next();\n      _addSeriesToStudy(studyMetadata, series);\n      forceRerender();\n      return loadNextSeries();\n    };\n\n    const concurrentRequestsAllowed =\n      maxConcurrentMetadataRequests || studyMetadata.getSeriesCount();\n    const promises = Array(concurrentRequestsAllowed)\n      .fill(null)\n      .map(loadNextSeries);\n\n    return await Promise.all(promises);\n  };\n\n  const loadStudies = async () => {\n    console.log(\"loadStudies()\");\n    try {\n      const filters = {};\n      // Use the first, discard others\n      const seriesInstanceUID = seriesInstanceUIDs && seriesInstanceUIDs[0];\n      const retrieveParams = [server, studyInstanceUIDs];\n\n      if (seriesInstanceUID) {\n        filters.seriesInstanceUID = seriesInstanceUID;\n        // Query param filtering controlled by appConfig property\n        if (isFilterStrategy) {\n          retrieveParams.push(filters);\n        }\n      }\n\n      if (\n        appConfig.splitQueryParameterCalls ||\n        appConfig.enableGoogleCloudAdapter\n      ) {\n        retrieveParams.push(true); // Seperate SeriesInstanceUID filter calls.\n      }\n\n      cancelableStudiesPromises[studyInstanceUIDs] = makeCancelable(\n        retrieveStudiesMetadata(...retrieveParams)\n      )\n        .then(result => {\n          if (result && !result.isCanceled) {\n            processStudies(result, filters);\n          }\n        })\n        .catch(error => {\n          if (error && !error.isCanceled) {\n            setError(error);\n            log.error(error);\n          }\n        });\n    } catch (error) {\n      if (error) {\n        setError(error);\n        log.error(error);\n      }\n    }\n  };\n\n  const purgeCancellablePromises = useCallback(() => {\n    for (let studyInstanceUIDs in cancelableStudiesPromises) {\n      if ('cancel' in cancelableStudiesPromises[studyInstanceUIDs]) {\n        cancelableStudiesPromises[studyInstanceUIDs].cancel();\n      }\n    }\n\n    for (let studyInstanceUIDs in cancelableSeriesPromises) {\n      if ('cancel' in cancelableSeriesPromises[studyInstanceUIDs]) {\n        cancelableSeriesPromises[studyInstanceUIDs].cancel();\n        deleteStudyMetadataPromise(studyInstanceUIDs);\n        studyMetadataManager.remove(studyInstanceUIDs);\n      }\n    }\n  });\n\n  const prevStudyInstanceUIDs = usePrevious(studyInstanceUIDs);\n  const hasStudyInstanceUIDsChanged = !(\n    prevStudyInstanceUIDs &&\n    prevStudyInstanceUIDs.every(e => studyInstanceUIDs.includes(e)) &&\n    studyInstanceUIDs.every(e => prevStudyInstanceUIDs.includes(e))\n  );\n\n  useEffect(() => {\n    if (hasStudyInstanceUIDsChanged) {\n      studyMetadataManager.purge();\n      purgeCancellablePromises();\n    }\n  }, [prevStudyInstanceUIDs, purgeCancellablePromises, studyInstanceUIDs]);\n\n  useEffect(() => {\n    if (hasStudyInstanceUIDsChanged) {\n      cancelableSeriesPromises = {};\n      cancelableStudiesPromises = {};\n      loadStudies();\n      return () => {\n        purgeCancellablePromises();\n      };\n    }\n  }, [studyInstanceUIDs]);\n\n  if (error) {\n    const content = JSON.stringify(error);\n    if (content.includes('404') || content.includes('NOT_FOUND')) {\n      return <NotFound />;\n    }\n\n    return <NotFound message=\"Failed to retrieve study data\" />;\n  }\n\n  return (\n    <ConnectedViewer\n      studies={studies}\n      isStudyLoaded={isStudyLoaded}\n      studyInstanceUIDs={studyInstanceUIDs}\n      patientID={patientID}\n    />\n  );\n}\n\nViewerRetrieveStudyData.propTypes = {\n  studyInstanceUIDs: PropTypes.array.isRequired,\n  seriesInstanceUIDs: PropTypes.array,\n  server: PropTypes.object,\n  clearViewportSpecificData: PropTypes.func.isRequired,\n  setStudyData: PropTypes.func.isRequired,\n};\n\nexport default ViewerRetrieveStudyData;\n","import { connect } from 'react-redux';\nimport ViewerRetrieveStudyData from './ViewerRetrieveStudyData.js';\nimport OHIF from '@ohif/core';\n\nconst { clearViewportSpecificData, setStudyData } = OHIF.redux.actions;\nconst isActive = a => a.active === true;\n\nconst mapStateToProps = (state, ownProps) => {\n  const activeServer = state.servers.servers.find(isActive);\n  console.log(\"mapStateToProps for ConnectedViewerRetrieveStudyData\");\n  console.log(state.studies.studyData);\n  const studyInstanceUIDs = Object.keys(state.studies.studyData);\n\n  return {\n    server: ownProps.server || activeServer,\n    studyInstanceUIDs: studyInstanceUIDs\n  };\n};\nconst mapDispatchToProps = dispatch => {\n  return {\n    setStudyData: (StudyInstanceUID, data) => {\n      dispatch(setStudyData(StudyInstanceUID, data));\n    },\n    clearViewportSpecificData: () => {\n      dispatch(clearViewportSpecificData());\n    },\n  };\n};\n\nconst ConnectedViewerRetrieveStudyData = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(ViewerRetrieveStudyData);\n\nexport default ConnectedViewerRetrieveStudyData;\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","import React, { Component } from 'react';\nimport OHIF from '@ohif/core';\nimport PropTypes from 'prop-types';\nimport qs from 'querystring';\n\nimport { extensionManager } from './../App.js';\nimport ConnectedViewer from '../connectedComponents/ConnectedViewer';\nimport ConnectedViewerRetrieveStudyData from '../connectedComponents/ConnectedViewerRetrieveStudyData';\nimport NotFound from '../routes/NotFound';\n\nconst { log, metadata, utils } = OHIF;\nconst { studyMetadataManager } = utils;\nconst { OHIFStudyMetadata } = metadata;\n\nclass StandaloneRouting extends Component {\n  state = {\n    studies: null,\n    server: null,\n    studyInstanceUIDs: null,\n    seriesInstanceUIDs: null,\n    error: null,\n    loading: true,\n  };\n\n  static propTypes = {\n    location: PropTypes.object,\n    store: PropTypes.object,\n    setServers: PropTypes.func,\n  };\n\n  parseQueryAndRetrieveDICOMWebData(query) {\n    return new Promise((resolve, reject) => {\n      const url = query.url;\n\n      if (!url) {\n        return reject(new Error('No URL was specified. Use ?url=$yourURL'));\n      }\n\n      // Define a request to the server to retrieve the study data\n      // as JSON, given a URL that was in the Route\n      const oReq = new XMLHttpRequest();\n\n      // Add event listeners for request failure\n      oReq.addEventListener('error', error => {\n        log.warn('An error occurred while retrieving the JSON data');\n        reject(error);\n      });\n\n      // When the JSON has been returned, parse it into a JavaScript Object\n      // and render the OHIF Viewer with this data\n      oReq.addEventListener('load', event => {\n        if (event.target.status === 404) {\n          reject(new Error('No JSON data found'));\n        }\n\n        // Parse the response content\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseText\n        if (!oReq.responseText) {\n          log.warn('Response was undefined');\n          reject(new Error('Response was undefined'));\n        }\n\n        log.info(JSON.stringify(oReq.responseText, null, 2));\n\n        const data = JSON.parse(oReq.responseText);\n        if (data.servers) {\n          if (!query.studyInstanceUIDs) {\n            log.warn('No study instance uids specified');\n            reject(new Error('No study instance uids specified'));\n          }\n\n          const server = data.servers.dicomWeb[0];\n          server.type = 'dicomWeb';\n\n          log.warn('Activating server', server);\n          this.props.activateServer(server);\n\n          const studyInstanceUIDs = query.studyInstanceUIDs.split(';');\n          const seriesInstanceUIDs = query.seriesInstanceUIDs\n            ? query.seriesInstanceUIDs.split(';')\n            : [];\n\n          resolve({ server, studyInstanceUIDs, seriesInstanceUIDs });\n        } else {\n          // Parse data here and add to metadata provider.\n          const metadataProvider = OHIF.cornerstone.metadataProvider;\n\n          let StudyInstanceUID;\n          let SeriesInstanceUID;\n\n          data.studies.forEach(study => {\n            StudyInstanceUID = study.StudyInstanceUID;\n\n            study.series.forEach(series => {\n              SeriesInstanceUID = series.SeriesInstanceUID;\n\n              series.instances.forEach(instance => {\n                const { url: imageId, metadata: naturalizedDicom } = instance;\n\n                // Add instance to metadata provider.\n                metadataProvider.addInstance(naturalizedDicom);\n                // Add imageId specific mapping to this data as the URL isn't necessarliy WADO-URI.\n                metadataProvider.addImageIdToUIDs(imageId, {\n                  StudyInstanceUID,\n                  SeriesInstanceUID,\n                  SOPInstanceUID: naturalizedDicom.SOPInstanceUID,\n                });\n              });\n            });\n          });\n\n          resolve({ studies: data.studies, studyInstanceUIDs: [] });\n        }\n      });\n\n      // Open the Request to the server for the JSON data\n      // In this case we have a server-side route called /api/\n      // which responds to GET requests with the study data\n      log.info(`Sending Request to: ${url}`);\n      oReq.open('GET', url);\n      oReq.setRequestHeader('Accept', 'application/json');\n\n      // Fire the request to the server\n      oReq.send();\n    });\n  }\n\n  async componentDidMount() {\n    try {\n      let { search } = this.props.location;\n\n      // Remove ? prefix which is included for some reason\n      search = search.slice(1, search.length);\n      const query = qs.parse(search);\n\n      let {\n        server,\n        studies,\n        studyInstanceUIDs,\n        seriesInstanceUIDs,\n      } = await this.parseQueryAndRetrieveDICOMWebData(query);\n\n      if (studies) {\n        const {\n          studies: updatedStudies,\n          studyInstanceUIDs: updatedStudiesInstanceUIDs,\n        } = _mapStudiesToNewFormat(studies);\n        studies = updatedStudies;\n        studyInstanceUIDs = updatedStudiesInstanceUIDs;\n      }\n\n      this.setState({\n        studies,\n        server,\n        studyInstanceUIDs,\n        seriesInstanceUIDs,\n        loading: false,\n      });\n    } catch (error) {\n      this.setState({ error: error.message, loading: false });\n    }\n  }\n\n  render() {\n    const message = this.state.error\n      ? `Error: ${JSON.stringify(this.state.error)}`\n      : 'Loading...';\n    if (this.state.error || this.state.loading) {\n      return <NotFound message={message} showGoBackButton={this.state.error} />;\n    }\n\n    return this.state.studies ? (\n      <ConnectedViewer studies={this.state.studies} />\n    ) : (\n      <ConnectedViewerRetrieveStudyData\n        studyInstanceUIDs={this.state.studyInstanceUIDs}\n        seriesInstanceUIDs={this.state.seriesInstanceUIDs}\n        server={this.state.server}\n      />\n    );\n  }\n}\n\nconst _mapStudiesToNewFormat = studies => {\n  studyMetadataManager.purge();\n\n  /* Map studies to new format, update metadata manager? */\n  const uniqueStudyUIDs = new Set();\n  const updatedStudies = studies.map(study => {\n    const studyMetadata = new OHIFStudyMetadata(study, study.StudyInstanceUID);\n\n    const sopClassHandlerModules =\n      extensionManager.modules['sopClassHandlerModule'];\n    study.displaySets =\n      study.displaySets ||\n      studyMetadata.createDisplaySets(sopClassHandlerModules);\n\n    studyMetadataManager.add(studyMetadata);\n    uniqueStudyUIDs.add(study.StudyInstanceUID);\n\n    return study;\n  });\n\n  return {\n    studies: updatedStudies,\n    studyInstanceUIDs: Array.from(uniqueStudyUIDs),\n  };\n};\n\nexport default StandaloneRouting;\n","import { connect } from 'react-redux';\nimport StandaloneRouting from '../routes/StandaloneRouting';\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    activateServer: server => {\n      const action = {\n        type: 'ACTIVATE_SERVER',\n        server,\n      };\n      dispatch(action);\n    },\n  };\n};\n\nconst ConnectedStandaloneRouting = connect(\n  null,\n  mapDispatchToProps\n)(StandaloneRouting);\n\nexport default ConnectedStandaloneRouting;\n"],"sourceRoot":""}